<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ALSA project - the C library reference: Topology Interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ALSA project - the C library reference
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Topology Interface</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__tlv__template.html">snd_tplg_tlv_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type for all TLV objects.  <a href="structsnd__tplg__tlv__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__tlv__dbscale__template.html">snd_tplg_tlv_dbscale_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type for TLV Scale objects.  <a href="structsnd__tplg__tlv__dbscale__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__channel__elem.html">snd_tplg_channel_elem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__channel__map__template.html">snd_tplg_channel_map_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type for channel mapping.  <a href="structsnd__tplg__channel__map__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__pdata__template.html">snd_tplg_pdata_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type for private data objects.  <a href="structsnd__tplg__pdata__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__io__ops__template.html">snd_tplg_io_ops_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type for object operations mapping.  <a href="structsnd__tplg__io__ops__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__ctl__template.html">snd_tplg_ctl_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type for control objects.  <a href="structsnd__tplg__ctl__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__mixer__template.html">snd_tplg_mixer_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type for mixer control objects.  <a href="structsnd__tplg__mixer__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__enum__template.html">snd_tplg_enum_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type for enumerated control objects.  <a href="structsnd__tplg__enum__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__bytes__template.html">snd_tplg_bytes_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type for TLV Scale objects.  <a href="structsnd__tplg__bytes__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__graph__elem.html">snd_tplg_graph_elem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type for single DAPM graph element.  <a href="structsnd__tplg__graph__elem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__graph__template.html">snd_tplg_graph_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type for array of DAPM graph elements.  <a href="structsnd__tplg__graph__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__widget__template.html">snd_tplg_widget_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type for DAPM widget objects.  <a href="structsnd__tplg__widget__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__stream__template.html">snd_tplg_stream_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream configurations.  <a href="structsnd__tplg__stream__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__stream__caps__template.html">snd_tplg_stream_caps_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream Capabilities.  <a href="structsnd__tplg__stream__caps__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__pcm__template.html">snd_tplg_pcm_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type for PCM (FE DAI &amp; DAI links).  <a href="structsnd__tplg__pcm__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__hw__config__template.html">snd_tplg_hw_config_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type to describe a physical link runtime supported hardware config, i.e. hardware audio formats.  <a href="structsnd__tplg__hw__config__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__dai__template.html">snd_tplg_dai_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type for physical DAI. It can be used to configure backend DAIs for DPCM.  <a href="structsnd__tplg__dai__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__link__template.html">snd_tplg_link_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type for physical DAI Links.  <a href="structsnd__tplg__link__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__obj__template__t.html">snd_tplg_obj_template_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__channel__template.html">snd_tplg_channel_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template type for single channel mapping.  <a href="structsnd__tplg__channel__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsnd__tplg__obj__template.html">snd_tplg_obj_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic Template Object.  <a href="structsnd__tplg__obj__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga166b4ca9decf8ffd675f06c96d265490"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__topology.html#ga166b4ca9decf8ffd675f06c96d265490">SND_TPLG_MAX_CHAN</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:ga166b4ca9decf8ffd675f06c96d265490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28f1657bb57406ee17c99cc19d8ff215"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__topology.html#ga28f1657bb57406ee17c99cc19d8ff215">SND_TPLG_INDEX_ALL</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga28f1657bb57406ee17c99cc19d8ff215"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga85fcf522a65a5da8f57d83eec2eea98e"><td class="memItemLeft" align="right" valign="top">typedef struct snd_tplg&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a></td></tr>
<tr class="separator:ga85fcf522a65a5da8f57d83eec2eea98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga465b5b8dea36052ad6fb12e2886f8757"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__topology.html#ga465b5b8dea36052ad6fb12e2886f8757">snd_tplg_type</a> { <br />
&#160;&#160;<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757aaf27c1cc4c621a45d46432326a1aa888">SND_TPLG_TYPE_TLV</a> = 0, 
<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757a96c0e408a18ede418d5e88b15a1a092d">SND_TPLG_TYPE_MIXER</a>, 
<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757acd5e9bf0971828063b10a6ce1c5f5d06">SND_TPLG_TYPE_ENUM</a>, 
<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757a001f35143cd77fc5d1ffcf943197f05f">SND_TPLG_TYPE_TEXT</a>, 
<br />
&#160;&#160;<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757a465f9e3757181d5cfc2198b072445f96">SND_TPLG_TYPE_DATA</a>, 
<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757abfabfba93f42f3480ba1a157b040d2c9">SND_TPLG_TYPE_BYTES</a>, 
<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757a0f7aab87018f1c08cf34d85331eaf04e">SND_TPLG_TYPE_STREAM_CONFIG</a>, 
<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757a0aaae49f2f43033ea4492a244ff4d6c7">SND_TPLG_TYPE_STREAM_CAPS</a>, 
<br />
&#160;&#160;<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757ab9c96aed8ec27baa5174b95c1a48f24e">SND_TPLG_TYPE_PCM</a>, 
<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757ad4dc07d95c540edc290caa096f782638">SND_TPLG_TYPE_DAPM_WIDGET</a>, 
<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757a60c8b0cf1870569f70e09efe0a1335fa">SND_TPLG_TYPE_DAPM_GRAPH</a>, 
<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757a8f1276de125c64cd18d4de09f077057b">SND_TPLG_TYPE_BE</a>, 
<br />
&#160;&#160;<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757a88677abcdb522863847c547c5f48ab46">SND_TPLG_TYPE_CC</a>, 
<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757a0728bac919b44131c4181976964aba47">SND_TPLG_TYPE_MANIFEST</a>, 
<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757a3a9bcd3df54f0eb979b8e30611dca531">SND_TPLG_TYPE_TOKEN</a>, 
<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757ac8749fd8387d76b060e8954286e05403">SND_TPLG_TYPE_TUPLE</a>, 
<br />
&#160;&#160;<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757a6c902fd43a05f900a35c8e73dc853755">SND_TPLG_TYPE_LINK</a>, 
<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757a418ddc4b18fd0f9998dbc5eaddfd3bea">SND_TPLG_TYPE_HW_CONFIG</a>, 
<a class="el" href="group__topology.html#gga465b5b8dea36052ad6fb12e2886f8757a6163e1b023ee7a14c6ddd555df9083a3">SND_TPLG_TYPE_DAI</a>
<br />
 }</td></tr>
<tr class="separator:ga465b5b8dea36052ad6fb12e2886f8757"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga33eea73f6e3a5a1cdb4af78482fd007b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__topology.html#ga33eea73f6e3a5a1cdb4af78482fd007b">snd_tplg_new</a> (void)</td></tr>
<tr class="memdesc:ga33eea73f6e3a5a1cdb4af78482fd007b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new topology parser instance.  <a href="#ga33eea73f6e3a5a1cdb4af78482fd007b">More...</a><br /></td></tr>
<tr class="separator:ga33eea73f6e3a5a1cdb4af78482fd007b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad0311f45ec180cced72c0500f42b14f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__topology.html#gad0311f45ec180cced72c0500f42b14f0">snd_tplg_free</a> (<a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a> *tplg)</td></tr>
<tr class="memdesc:gad0311f45ec180cced72c0500f42b14f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a topology parser instance.  <a href="#gad0311f45ec180cced72c0500f42b14f0">More...</a><br /></td></tr>
<tr class="separator:gad0311f45ec180cced72c0500f42b14f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32610ecd4d4d3d8b298ed6eea9ee19cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__topology.html#ga32610ecd4d4d3d8b298ed6eea9ee19cc">snd_tplg_build_file</a> (<a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a> *tplg, const char *infile, const char *outfile)</td></tr>
<tr class="memdesc:ga32610ecd4d4d3d8b298ed6eea9ee19cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse and build topology text file into binary file.  <a href="#ga32610ecd4d4d3d8b298ed6eea9ee19cc">More...</a><br /></td></tr>
<tr class="separator:ga32610ecd4d4d3d8b298ed6eea9ee19cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4682edcfc48f7f4c90c238ebffc0260"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__topology.html#gac4682edcfc48f7f4c90c238ebffc0260">snd_tplg_verbose</a> (<a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a> *tplg, int verbose)</td></tr>
<tr class="memdesc:gac4682edcfc48f7f4c90c238ebffc0260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable verbose reporting of binary file output.  <a href="#gac4682edcfc48f7f4c90c238ebffc0260">More...</a><br /></td></tr>
<tr class="separator:gac4682edcfc48f7f4c90c238ebffc0260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05ff9c8d200b65c8511ef498443e0f5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__topology.html#ga05ff9c8d200b65c8511ef498443e0f5b">snd_tplg_add_object</a> (<a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a> *tplg, <a class="el" href="structsnd__tplg__obj__template__t.html">snd_tplg_obj_template_t</a> *t)</td></tr>
<tr class="memdesc:ga05ff9c8d200b65c8511ef498443e0f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register topology template object.  <a href="#ga05ff9c8d200b65c8511ef498443e0f5b">More...</a><br /></td></tr>
<tr class="separator:ga05ff9c8d200b65c8511ef498443e0f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga537e8f4fa495e40f8fc9a8d7c4ea8840"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__topology.html#ga537e8f4fa495e40f8fc9a8d7c4ea8840">snd_tplg_build</a> (<a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a> *tplg, const char *outfile)</td></tr>
<tr class="memdesc:ga537e8f4fa495e40f8fc9a8d7c4ea8840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build all registered topology data into binary file.  <a href="#ga537e8f4fa495e40f8fc9a8d7c4ea8840">More...</a><br /></td></tr>
<tr class="separator:ga537e8f4fa495e40f8fc9a8d7c4ea8840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbb1cc2f7389e77d2d31919296e7e896"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__topology.html#gabbb1cc2f7389e77d2d31919296e7e896">snd_tplg_set_manifest_data</a> (<a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a> *tplg, const void *data, int <a class="el" href="seq__event_8h.html#a77124bd5f7e31e6fffc19f335da0c23f">len</a>)</td></tr>
<tr class="memdesc:gabbb1cc2f7389e77d2d31919296e7e896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach private data to topology manifest.  <a href="#gabbb1cc2f7389e77d2d31919296e7e896">More...</a><br /></td></tr>
<tr class="separator:gabbb1cc2f7389e77d2d31919296e7e896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga389e200fa8c0b4b2c4c7352486874620"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__topology.html#ga389e200fa8c0b4b2c4c7352486874620">snd_tplg_set_version</a> (<a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a> *tplg, unsigned int version)</td></tr>
<tr class="memdesc:ga389e200fa8c0b4b2c4c7352486874620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an optional vendor specific version number.  <a href="#ga389e200fa8c0b4b2c4c7352486874620">More...</a><br /></td></tr>
<tr class="separator:ga389e200fa8c0b4b2c4c7352486874620"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>


<h3><a class="anchor" id="topology"></a>ALSA Topology Interface</h3><div class="textblock">The topology interface allows developers to define DSP topologies in a text file format and to convert the text topology to a binary topology representation that can be understood by the kernel. The topology core currently recognises the following object types :-<ul>
<li>Controls (mixer, enumerated and byte) including TLV data.</li>
<li>PCMs (Front End DAI &amp; DAI link)</li>
<li>DAPM widgets</li>
<li>DAPM graph elements.</li>
<li>Physical DAI &amp; DAI links</li>
<li>Private data for each object type.</li>
<li>Manifest (containing count of each object type)</li>
</ul>
<h3>Topology File Format</h3>
The topology text format uses the standard ALSA configuration file format to describe each topology object type. This allows topology objects to include other topology objects as part of their definition. i.e. a TLV data object can be shared amongst many control objects that use the same TLV data.<h4>Controls</h4>
Topology audio controls can belong to three different types :-</p><ul>
<li>Mixer control</li>
<li>Enumerated control</li>
<li>Byte control</li>
</ul>
Each control type can contain TLV data, private data, operations and also belong to widget objects.<br />
<h5>Control Operations</h5>
Driver Kcontrol callback info(), get() and put() operations are mapped with the CTL ops section in topology configuration files. The ctl ops section can assign operations using the standard names (listed below) for the standard kcontrol types or use ID numbers (&gt;256) to map to bespoke driver controls.<br />
<pre></pre><pre>    ops."ctl" {
        info "volsw"
        get "257"
        put "257"
    }</pre><pre> </pre>This mapping shows info() using the standard "volsw" info callback whilst the get() and put() are mapped to bespoke driver callbacks. <br />
The Standard operations names for control get(), put() and info calls are :-</p><ul>
<li>volsw</li>
<li>volsw_sx</li>
<li>volsw_xr_sx</li>
<li>enum</li>
<li>bytes</li>
<li>enum_value</li>
<li>range</li>
<li>strobe</li>
</ul>
<h5>Control Access</h5>
Controls access can be specified using the "access" section. If no "access" section is defined then default RW access flags are set for normal and TLV controls.<pre>
    access [
        read
        write
        tlv_command
    ]
 </pre>The standard access flags are as follows :-</p><ul>
<li>read</li>
<li>write</li>
<li>read_write</li>
<li>volatile</li>
<li>timestamp</li>
<li>tlv_read</li>
<li>tlv_write</li>
<li>tlv_read_write</li>
<li>tlv_command</li>
<li>inactive</li>
<li>lock</li>
<li>owner</li>
<li>tlv_callback</li>
<li>user</li>
</ul>
<h5>Control TLV Data</h5>
Controls can also use TLV data to represent dB information. This can be done by defining a TLV section and using the TLV section within the control. The TLV data for DBScale types are defined as follows :-<pre>
    scale {
        min "-9000"
        step "300"
        mute "1"
    }
 </pre>Where the meanings and values for min, step and mute are exactly the same as defined in driver code.<h5>Control Channel Mapping</h5>
Controls can also specify which channels they are mapped with. This is useful for userspace as it allows applications to determine the correct control channel for Left and Right etc. Channel maps are defined as follows :-<pre>
    channel."name" {
        reg "0"
        shift "0"
    }
 </pre>The channel map reg is the register offset for the control, shift is the bit shift within the register for the channel and the section name is the channel name and can be one of the following :-<pre>
  * mono        # mono stream
  * fl      # front left
  * fr      # front right
  * rl      # rear left
  * rr      # rear right
  * fc      # front center
  * lfe     # LFE
  * sl      # side left
  * sr      # side right
  * rc      # rear center
  * flc     # front left center
  * frc     # front right center
  * rlc     # rear left center
  * rrc     # rear right center
  * flw     # front left wide
  * frw     # front right wide
  * flh     # front left high
  * fch     # front center high
  * frh     # front right high
  * tc      # top center
  * tfl     # top front left
  * tfr     # top front right
  * tfc     # top front center
  * trl     # top rear left
  * trr     # top rear right
  * trc     # top rear center
  * tflc        # top front left center
  * tfrc        # top front right center
  * tsl     # top side left
  * tsr     # top side right
  * llfe        # left LFE
  * rlfe        # right LFE
  * bc      # bottom center
  * blc     # bottom left center
  * brc     # bottom right center
 </pre><h5>Control Private Data</h5>
Controls can also have private data. This can be done by defining a private data section and including the section within the control. The private data section is defined as follows :-<pre>
 SectionData."pdata for EQU1" {
    file "/path/to/file"
    bytes "0x12,0x34,0x56,0x78"
    shorts "0x1122,0x3344,0x5566,0x7788"
    words "0xaabbccdd,0x11223344,0x66aa77bb,0xefef1234"
    tuples "section id of the vendor tuples"
 };
 </pre><p> The file, bytes, shorts, words and tuples keywords are all mutually exclusive as the private data should only be taken from one source. The private data can either be read from a separate file or defined in the topology file using the bytes, shorts, words or tuples keywords. The keyword tuples is to define vendor specific tuples. Please refer to section Vendor Tokens and Vendor tuples.It's easy to use a vendor tuples object to define a C structure instance. And a data section can include multiple vendor tuples objects:<pre>
 SectionData."data element name" {
    index "1"   #Index number
    tuples [
        "id of the 1st vendor tuples section"
        "id of the 2nd vendor tuples section"
        ...
    ]
 };
 </pre><h5>How to define an element with private data</h5>
An element can refer to a single data section or multiple data sections.<h6>To refer to a single data section:</h6>
<pre>
 Sectionxxx."element name" {
    ...
    data "name of data section"     # optional private data
 }
 </pre><h6>To refer to multiple data sections:</h6>
<pre>
 Sectionxxx."element name" {
    ...
    data [                      # optional private data
        "name of 1st data section"
        "name of 2nd data section"
        ...
    ]
 }
 </pre><p> And data of these sections will be merged in the same order as they are in the list, as the element's private data for kernel.<h6>Vendor Tokens</h6>
A vendor token list is defined as a new section. Each token element is a pair of string ID and integer value. And both the ID and value are vendor-specific.<pre>
 SectionVendorTokens."id of the vendor tokens" {
    comment "optional comments"
    VENDOR_TOKEN_ID1 "1"
    VENDOR_TOKEN_ID2 "2"
    VENDOR_TOKEN_ID3 "3"
    ...
 }
 </pre><h6>Vendor Tuples</h6>
Vendor tuples are defined as a new section. It contains a reference to a vendor token list and several tuple arrays. All arrays share a vendor token list, defined by the tokens keyword. Each tuple array is for a specific type, defined by the string following the tuples keyword. Supported types are: string, uuid, bool, byte, short and word.<pre>
 SectionVendorTuples."id of the vendor tuples" {
    tokens "id of the vendor tokens"</pre><pre>    tuples."string" {
        VENDOR_TOKEN_ID1 "character string"
        ...
    }</pre><pre>    tuples."uuid" {         # 16 characters separated by commas
        VENDOR_TOKEN_ID2 "0x01,0x02,...,0x0f"
        ...
    }</pre><pre>    tuples."bool" {
        VENDOR_TOKEN_ID3 "true/false"
        ...
    }</pre><pre>    tuples."byte" {
        VENDOR_TOKEN_ID4 "0x11"
        VENDOR_TOKEN_ID5 "0x22"
        ...
    }</pre><pre>    tuples."short" {
        VENDOR_TOKEN_ID6 "0x1122"
        VENDOR_TOKEN_ID7 "0x3344"
        ...
    }</pre><pre>    tuples."word" {
        VENDOR_TOKEN_ID8 "0x11223344"
        VENDOR_TOKEN_ID9 "0x55667788"
        ...
    }
 }
 </pre><p> To define multiple vendor tuples of same type, please append some characters after the type string ("string", "uuid", "bool", "byte", "short" or "word"), to avoid ID duplication in the SectionVendorTuples.<br />
 The parser will check the first few characters in ID to get the tuple type. Here is an example: </p><pre>
 SectionVendorTuples."id of the vendor tuples" {
    ...
    tuples."word.module0" {
        VENDOR_TOKEN_PARAM_ID1 "0x00112233"
        VENDOR_TOKEN_PARAM_ID2 "0x44556677"
        ...
    }</pre><pre>    tuples."word.module2" {
        VENDOR_TOKEN_PARAM_ID1 "0x11223344"
        VENDOR_TOKEN_PARAM_ID2 "0x55667788"
        ...
    }
    ...
 }</pre><pre> </pre><h5>Mixer Controls</h5>
A mixer control is defined as a new section that can include channel mapping, TLV data, callback operations and private data. The mixer section also includes a few other config options that are shown here :-<pre>
 SectionControlMixer."mixer name" {
    comment "optional comments"</pre><pre>    index "1"           # Index number</pre><pre>    channel."name" {        # Channel maps
       ....
    }</pre><pre>    ops."ctl" {         # Ops callback functions
       ....
    }</pre><pre>    max "32"            # Max control value
    invert "0"          # Whether control values are inverted</pre><pre>    tlv "tld_data"          # optional TLV data</pre><pre>    data "pdata for mixer1"     # optional private data
 }
 </pre>The section name is used to define the mixer name. The index number can be used to identify topology objects groups(index "0" is common, fit for all user cases).This allows driver operations on objects with index number N and can be used to add/remove pipelines of objects whilst other objects are unaffected.<h5>Byte Controls</h5>
A byte control is defined as a new section that can include channel mapping, TLV data, callback operations and private data. The bytes section also includes a few other config options that are shown here :-<pre>
 SectionControlBytes."name" {
    comment "optional comments"</pre><pre>    index "1"           # Index number</pre><pre>    channel."name" {        # Channel maps
       ....
    }</pre><pre>    ops."ctl" {         # Ops callback functions
       ....
    }</pre><pre>    base "0"            # Register base
    num_regs "16"           # Number of registers
    mask "0xff"         # Mask
    max "255"           # Maximum value</pre><pre>    tlv "tld_data"          # optional TLV data</pre><pre>    data "pdata for mixer1"     # optional private data
 }
 </pre><h5>Enumerated Controls</h5>
A enumerated control is defined as a new section (like mixer and byte) that can include channel mapping, callback operations, private data and text strings to represent the enumerated control options.<br />
The text strings for the enumerated controls are defined in a separate section as follows :-<pre>
 SectionText."name" {</pre><pre>        Values [
            "value1"
            "value2"
        "value3"
        ]
 }
 </pre>All the enumerated text values are listed in the values list.<br />
 The enumerated control is similar to the other controls and defined as follows :-<pre>
 SectionControlMixer."name" {
    comment "optional comments"</pre><pre>    index "1"           # Index number</pre><pre>    texts "EQU1"            # Enumerated text items</pre><pre>    channel."name" {        # Channel maps
       ....
    }</pre><pre>    ops."ctl" {         # Ops callback functions
       ....
    }</pre><pre>    data "pdata for mixer1"     # optional private data
 }
 </pre><h4>DAPM Graph</h4>
DAPM graphs can easily be defined using the topology file. The format is very similar to the DAPM graph kernel format. :-<pre>
 SectionGraph."dsp" {
    index "1"           # Index number</pre><pre>    lines [
        "sink1, control, source1"
        "sink2, , source2"
    ]
 }
 </pre>The lines in the graph are defined as a variable size list of sinks, controls and sources. The control name is optional as some graph lines have no associated controls. The section name can be used to differentiate the graph with other graphs, it's not used by the kernel atm.<h4>DAPM Widgets</h4>
DAPM widgets are similar to controls in that they can include many other objects. Widgets can contain private data, mixer controls and enum controls.The following widget types are supported and match the driver types :-<ul>
<li>input</li>
<li>output</li>
<li>mux</li>
<li>mixer</li>
<li>pga</li>
<li>out_drv</li>
<li>adc</li>
<li>dac</li>
<li>switch</li>
<li>pre</li>
<li>post</li>
<li>aif_in</li>
<li>aif_out</li>
<li>dai_in</li>
<li>dai_out</li>
<li>dai_link</li>
</ul>
Widgets are defined as follows :-<pre>
 SectionWidget."name" {</pre><pre>    index "1"           # Index number</pre><pre>    type "aif_in"           # Widget type - detailed above
    stream_name "name"      # Stream name</pre><pre>    no_pm "true"            # No PM control bit.
    reg "20"            # PM bit register offset
    shift "0"           # PM bit register shift
    invert "1           # PM bit is inverted
    subseq "8"          # subsequence number</pre><pre>    event_type "1"          # DAPM widget event type
    event_flags "1"         # DAPM widget event flags</pre><pre>    mixer "name"            # Optional Mixer Control
    enum "name"         # Optional Enum Control</pre><pre>    data "name"         # optional private data
 }
 </pre>The section name is the widget name. The mixer and enum fields are mutually exclusive and used to include controls into the widget. The index and data fields are the same for widgets as they are for controls whilst the other fields map on very closely to the driver widget fields.<h5>Widget Private Data</h5>
Widget can have private data. For the format of the private data, please refer to section Control Private Data.<h4>PCM Capabilities</h4>
Topology can also define the PCM capabilities of front end or physical DAIs. Capabilities can be defined with the following section :-<pre>
 SectionPCMCapabilities."name" {</pre><pre>    formats "S24_LE,S16_LE"     # Supported formats
    rates "48000"           # Supported rates
    rate_min "48000"        # Max supported sample rate
    rate_max "48000"        # Min supported sample rate
    channels_min "2"        # Min number of channels
    channels_max "2"        # max number of channels
 }
 </pre><p> The supported formats use the same naming convention as the driver macros. The PCM capabilities name can be referred to and included by PCM and physical DAI sections.<h4>PCM Configurations</h4>
PCM runtime configurations can be defined for playback and capture stream directions with the following section :-<pre>
 SectionPCMConfig."name" {</pre><pre>    config."playback" {     # playback config
        format "S16_LE"     # playback format
        rate "48000"        # playback sample rate
        channels "2"        # playback channels
        tdm_slot "0xf"      # playback TDM slot
    }</pre><pre>    config."capture" {      # capture config
        format "S16_LE"     # capture format
        rate "48000"        # capture sample rate
        channels "2"        # capture channels
        tdm_slot "0xf"      # capture TDM slot
    }
 }
 </pre>The supported formats use the same naming convention as the driver macros. The PCM configuration name can be referred to and included by PCM and physical link sections.<h4>PCM (Front-end DAI &amp; DAI link) </h4>
PCM sections define the supported capabilities and configurations for supported playback and capture streams, names and flags for front end DAI &amp; DAI links. Topology kernel driver will use a PCM object to create a pair of FE DAI &amp; DAI links.<pre>
 SectionPCM."name" {</pre><pre>    index "1"           # Index number</pre><pre>    id "0"              # used for binding to the PCM</pre><pre>    dai."name of front-end DAI" {
        id "0"      # used for binding to the front-end DAI
    }</pre><pre>    pcm."playback" {
        capabilities "capabilities1"    # capabilities for playback</pre><pre>        configs [       # supported configs for playback
            "config1"
            "config2"
        ]
    }</pre><pre>    pcm."capture" {
        capabilities "capabilities2"    # capabilities for capture</pre><pre>        configs [       # supported configs for capture
            "config1"
            "config2"
            "config3"
        ]
    }</pre><pre>    # Optional boolean flags
    symmetric_rates         "true"
    symmetric_channels      "true"
    symmetric_sample_bits       "false"</pre><pre>    data "name"         # optional private data
 }
 </pre><h4>Physical DAI Link Configurations</h4>
The runtime configurations of a physical DAI link can be defined by SectionLink. <br />
 Backend DAI links belong to physical links, and can be configured by either SectionLink or SectionBE, with same syntax. But SectionBE is deprecated atm since the internal processing is actually same.<pre>
 SectionLink."name" {</pre><pre>    index "1"           # Index number</pre><pre>    id "0"              # used for binding to the link</pre><pre>    stream_name "name"      # used for binding to the link</pre><pre>    hw_configs [    # runtime supported HW configurations, optional
        "config1"
        "config2"
        ...
    ]</pre><pre>    default_hw_conf_id "1"      #default HW config ID for init</pre><pre>    # Optional boolean flags
    symmetric_rates         "true"
    symmetric_channels      "false"
    symmetric_sample_bits       "true"</pre><pre>    data "name"         # optional private data
 }
 </pre>A physical link can refer to multiple runtime supported hardware configurations, which is defined by SectionHWConfig.<pre>
 SectionHWConfig."name" {</pre><pre>    id "1"              # used for binding to the config
    format "I2S"            # physical audio format.
    bclk   "master"         # Platform is master of bit clock
    fsync  "slave"          # Platform is slave of fsync
 }
 </pre><h4>Physical DAI</h4>
A physical DAI (e.g. backend DAI for DPCM) is defined as a new section that can include a unique ID, playback and capture stream capabilities, optional flags, and private data. <br />
 Its PCM stream capablities are same as those for PCM objects, please refer to section 'PCM Capabilities'.<pre>
 SectionDAI."name" {</pre><pre>    index "1"           # Index number</pre><pre>    id "0"              # used for binding to the Backend DAI</pre><pre>    pcm."playback" {
        capabilities "capabilities1"    # capabilities for playback
    }</pre><pre>    pcm."capture" {
        capabilities "capabilities2"    # capabilities for capture
    }</pre><pre>    symmetric_rates "true"          # optional flags
    symmetric_channels "true"
    symmetric_sample_bits "false"</pre><pre>    data "name"         # optional private data
 }
 </pre><h4>Manifest Private Data</h4>
Manfiest may have private data. Users need to define a manifest section and add the references to 1 or multiple data sections. Please refer to section 'How to define an element with private data'. <br />
 And the text conf file can have at most 1 manifest section. <br />
<br />
Manifest section is defined as follows :-<pre>
 SectionManifest"name" {</pre><pre>    data "name"         # optional private data
 }
 </pre><h4>Include other files</h4>
Users may include other files in a text conf file via alsaconf syntax &lt;path/to/configuration-file&gt;. This allows users to define common info in separate files (e.g. vendor tokens, tuples) and share them for different platforms, thus save the total size of config files. <br />
 Users can also specifiy additional configuraiton directories relative to "/usr/share/alsa/" to search the included files, via alsaconf syntax &lt;searchfdir:/relative-path/to/usr/share/alsa&gt;. <br />
<br />
For example, file A and file B are two text conf files for platform X, they will be installed to /usr/share/alsa/topology/platformx. If we need file A to include file B, in file A we can add: <br />
&lt;searchdir:topology/platformx&gt; <br />
 &lt;name-of-file-B&gt; <br />
<br />
ALSA conf will search and open an included file in the following order of priority:</p><ol type="1">
<li>directly open the file by its name;</li>
<li>search for the file name in "/usr/share/alsa";</li>
<li>search for the file name in user specified subdirectories under "/usr/share/alsa".</li>
</ol>
The order of the included files need not to be same as their dependencies, since the topology library will load them all before parsing their dependencies. <br />
The configuration directories defined by a file will only be used to search the files included by this file. </div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga28f1657bb57406ee17c99cc19d8ff215"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SND_TPLG_INDEX_ALL&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fit for all user cases </p>

</div>
</div>
<a class="anchor" id="ga166b4ca9decf8ffd675f06c96d265490"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SND_TPLG_MAX_CHAN&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum number of channels supported in one control </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga85fcf522a65a5da8f57d83eec2eea98e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct snd_tplg <a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Topology context </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga465b5b8dea36052ad6fb12e2886f8757"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__topology.html#ga465b5b8dea36052ad6fb12e2886f8757">snd_tplg_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Topology object types </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757aaf27c1cc4c621a45d46432326a1aa888"></a>SND_TPLG_TYPE_TLV&#160;</td><td class="fielddoc">
<p>TLV Data </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757a96c0e408a18ede418d5e88b15a1a092d"></a>SND_TPLG_TYPE_MIXER&#160;</td><td class="fielddoc">
<p>Mixer control </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757acd5e9bf0971828063b10a6ce1c5f5d06"></a>SND_TPLG_TYPE_ENUM&#160;</td><td class="fielddoc">
<p>Enumerated control </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757a001f35143cd77fc5d1ffcf943197f05f"></a>SND_TPLG_TYPE_TEXT&#160;</td><td class="fielddoc">
<p>Text data </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757a465f9e3757181d5cfc2198b072445f96"></a>SND_TPLG_TYPE_DATA&#160;</td><td class="fielddoc">
<p>Private data </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757abfabfba93f42f3480ba1a157b040d2c9"></a>SND_TPLG_TYPE_BYTES&#160;</td><td class="fielddoc">
<p>Byte control </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757a0f7aab87018f1c08cf34d85331eaf04e"></a>SND_TPLG_TYPE_STREAM_CONFIG&#160;</td><td class="fielddoc">
<p>PCM Stream configuration </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757a0aaae49f2f43033ea4492a244ff4d6c7"></a>SND_TPLG_TYPE_STREAM_CAPS&#160;</td><td class="fielddoc">
<p>PCM Stream capabilities </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757ab9c96aed8ec27baa5174b95c1a48f24e"></a>SND_TPLG_TYPE_PCM&#160;</td><td class="fielddoc">
<p>PCM stream device </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757ad4dc07d95c540edc290caa096f782638"></a>SND_TPLG_TYPE_DAPM_WIDGET&#160;</td><td class="fielddoc">
<p>DAPM widget </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757a60c8b0cf1870569f70e09efe0a1335fa"></a>SND_TPLG_TYPE_DAPM_GRAPH&#160;</td><td class="fielddoc">
<p>DAPM graph elements </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757a8f1276de125c64cd18d4de09f077057b"></a>SND_TPLG_TYPE_BE&#160;</td><td class="fielddoc">
<p>BE DAI link </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757a88677abcdb522863847c547c5f48ab46"></a>SND_TPLG_TYPE_CC&#160;</td><td class="fielddoc">
<p>Hostless codec &lt;-&gt; codec link </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757a0728bac919b44131c4181976964aba47"></a>SND_TPLG_TYPE_MANIFEST&#160;</td><td class="fielddoc">
<p>Topology manifest </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757a3a9bcd3df54f0eb979b8e30611dca531"></a>SND_TPLG_TYPE_TOKEN&#160;</td><td class="fielddoc">
<p>Vendor tokens </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757ac8749fd8387d76b060e8954286e05403"></a>SND_TPLG_TYPE_TUPLE&#160;</td><td class="fielddoc">
<p>Vendor tuples </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757a6c902fd43a05f900a35c8e73dc853755"></a>SND_TPLG_TYPE_LINK&#160;</td><td class="fielddoc">
<p>Physical DAI link </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757a418ddc4b18fd0f9998dbc5eaddfd3bea"></a>SND_TPLG_TYPE_HW_CONFIG&#160;</td><td class="fielddoc">
<p>Link HW config </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga465b5b8dea36052ad6fb12e2886f8757a6163e1b023ee7a14c6ddd555df9083a3"></a>SND_TPLG_TYPE_DAI&#160;</td><td class="fielddoc">
<p>Physical DAI </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga05ff9c8d200b65c8511ef498443e0f5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snd_tplg_add_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a> *&#160;</td>
          <td class="paramname"><em>tplg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsnd__tplg__obj__template__t.html">snd_tplg_obj_template_t</a> *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register topology template object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tplg</td><td>Topology instance. </td></tr>
    <tr><td class="paramname">t</td><td>Template object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, otherwise a negative error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga537e8f4fa495e40f8fc9a8d7c4ea8840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snd_tplg_build </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a> *&#160;</td>
          <td class="paramname"><em>tplg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>outfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build all registered topology data into binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tplg</td><td>Topology instance. </td></tr>
    <tr><td class="paramname">outfile</td><td>Binary topology output file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, otherwise a negative error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga32610ecd4d4d3d8b298ed6eea9ee19cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snd_tplg_build_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a> *&#160;</td>
          <td class="paramname"><em>tplg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>infile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>outfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse and build topology text file into binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tplg</td><td>Topology instance. </td></tr>
    <tr><td class="paramname">infile</td><td>Topology text input file to be parsed </td></tr>
    <tr><td class="paramname">outfile</td><td>Binary topology output file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, otherwise a negative error code </dd></dl>

</div>
</div>
<a class="anchor" id="gad0311f45ec180cced72c0500f42b14f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void snd_tplg_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a> *&#160;</td>
          <td class="paramname"><em>tplg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a topology parser instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tplg</td><td>Topology parser instance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga33eea73f6e3a5a1cdb4af78482fd007b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a>* snd_tplg_new </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new topology parser instance. </p>
<dl class="section return"><dt>Returns</dt><dd>New topology parser instance </dd></dl>

</div>
</div>
<a class="anchor" id="gabbb1cc2f7389e77d2d31919296e7e896"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snd_tplg_set_manifest_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a> *&#160;</td>
          <td class="paramname"><em>tplg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach private data to topology manifest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tplg</td><td>Topology instance. </td></tr>
    <tr><td class="paramname">data</td><td>Private data. </td></tr>
    <tr><td class="paramname">len</td><td>Length of data in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, otherwise a negative error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga389e200fa8c0b4b2c4c7352486874620"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int snd_tplg_set_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a> *&#160;</td>
          <td class="paramname"><em>tplg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an optional vendor specific version number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tplg</td><td>Topology instance. </td></tr>
    <tr><td class="paramname">version</td><td>Vendor specific version number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zero on success, otherwise a negative error code </dd></dl>

</div>
</div>
<a class="anchor" id="gac4682edcfc48f7f4c90c238ebffc0260"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void snd_tplg_verbose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__topology.html#ga85fcf522a65a5da8f57d83eec2eea98e">snd_tplg_t</a> *&#160;</td>
          <td class="paramname"><em>tplg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable verbose reporting of binary file output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tplg</td><td>Topology Instance </td></tr>
    <tr><td class="paramname">verbose</td><td>Enable verbose output level if non zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
